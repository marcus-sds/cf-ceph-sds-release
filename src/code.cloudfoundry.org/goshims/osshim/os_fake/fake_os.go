// This file was generated by counterfeiter
package os_fake

import (
	"os"
	"sync"
	"time"

	"code.cloudfoundry.org/goshims/osshim"
)

type FakeOs struct {
	FindProcessStub        func(pid int) (*os.Process, error)
	findProcessMutex       sync.RWMutex
	findProcessArgsForCall []struct {
		pid int
	}
	findProcessReturns struct {
		result1 *os.Process
		result2 error
	}
	StartProcessStub        func(name string, argv []string, attr *os.ProcAttr) (*os.Process, error)
	startProcessMutex       sync.RWMutex
	startProcessArgsForCall []struct {
		name string
		argv []string
		attr *os.ProcAttr
	}
	startProcessReturns struct {
		result1 *os.Process
		result2 error
	}
	HostnameStub        func() (name string, err error)
	hostnameMutex       sync.RWMutex
	hostnameArgsForCall []struct{}
	hostnameReturns     struct {
		result1 string
		result2 error
	}
	ExpandStub        func(s string, mapping func(string) string) string
	expandMutex       sync.RWMutex
	expandArgsForCall []struct {
		s       string
		mapping func(string) string
	}
	expandReturns struct {
		result1 string
	}
	ExpandEnvStub        func(s string) string
	expandEnvMutex       sync.RWMutex
	expandEnvArgsForCall []struct {
		s string
	}
	expandEnvReturns struct {
		result1 string
	}
	GetenvStub        func(key string) string
	getenvMutex       sync.RWMutex
	getenvArgsForCall []struct {
		key string
	}
	getenvReturns struct {
		result1 string
	}
	LookupEnvStub        func(key string) (string, bool)
	lookupEnvMutex       sync.RWMutex
	lookupEnvArgsForCall []struct {
		key string
	}
	lookupEnvReturns struct {
		result1 string
		result2 bool
	}
	SetenvStub        func(key, value string) error
	setenvMutex       sync.RWMutex
	setenvArgsForCall []struct {
		key   string
		value string
	}
	setenvReturns struct {
		result1 error
	}
	UnsetenvStub        func(key string) error
	unsetenvMutex       sync.RWMutex
	unsetenvArgsForCall []struct {
		key string
	}
	unsetenvReturns struct {
		result1 error
	}
	ClearenvStub        func()
	clearenvMutex       sync.RWMutex
	clearenvArgsForCall []struct{}
	EnvironStub         func() []string
	environMutex        sync.RWMutex
	environArgsForCall  []struct{}
	environReturns      struct {
		result1 []string
	}
	NewSyscallErrorStub        func(syscall string, err error) error
	newSyscallErrorMutex       sync.RWMutex
	newSyscallErrorArgsForCall []struct {
		syscall string
		err     error
	}
	newSyscallErrorReturns struct {
		result1 error
	}
	IsExistStub        func(err error) bool
	isExistMutex       sync.RWMutex
	isExistArgsForCall []struct {
		err error
	}
	isExistReturns struct {
		result1 bool
	}
	IsNotExistStub        func(err error) bool
	isNotExistMutex       sync.RWMutex
	isNotExistArgsForCall []struct {
		err error
	}
	isNotExistReturns struct {
		result1 bool
	}
	IsPermissionStub        func(err error) bool
	isPermissionMutex       sync.RWMutex
	isPermissionArgsForCall []struct {
		err error
	}
	isPermissionReturns struct {
		result1 bool
	}
	GetpidStub        func() int
	getpidMutex       sync.RWMutex
	getpidArgsForCall []struct{}
	getpidReturns     struct {
		result1 int
	}
	GetppidStub        func() int
	getppidMutex       sync.RWMutex
	getppidArgsForCall []struct{}
	getppidReturns     struct {
		result1 int
	}
	MkdirStub        func(name string, perm os.FileMode) error
	mkdirMutex       sync.RWMutex
	mkdirArgsForCall []struct {
		name string
		perm os.FileMode
	}
	mkdirReturns struct {
		result1 error
	}
	ChdirStub        func(dir string) error
	chdirMutex       sync.RWMutex
	chdirArgsForCall []struct {
		dir string
	}
	chdirReturns struct {
		result1 error
	}
	OpenStub        func(name string) (osshim.File, error)
	openMutex       sync.RWMutex
	openArgsForCall []struct {
		name string
	}
	openReturns struct {
		result1 osshim.File
		result2 error
	}
	CreateStub        func(name string) (osshim.File, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		name string
	}
	createReturns struct {
		result1 osshim.File
		result2 error
	}
	RenameStub        func(oldpath, newpath string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		oldpath string
		newpath string
	}
	renameReturns struct {
		result1 error
	}
	NewFileStub        func(fd uintptr, name string) osshim.File
	newFileMutex       sync.RWMutex
	newFileArgsForCall []struct {
		fd   uintptr
		name string
	}
	newFileReturns struct {
		result1 osshim.File
	}
	OpenFileStub        func(name string, flag int, perm os.FileMode) (osshim.File, error)
	openFileMutex       sync.RWMutex
	openFileArgsForCall []struct {
		name string
		flag int
		perm os.FileMode
	}
	openFileReturns struct {
		result1 osshim.File
		result2 error
	}
	TruncateStub        func(name string, size int64) error
	truncateMutex       sync.RWMutex
	truncateArgsForCall []struct {
		name string
		size int64
	}
	truncateReturns struct {
		result1 error
	}
	RemoveStub        func(name string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		name string
	}
	removeReturns struct {
		result1 error
	}
	ChmodStub        func(name string, mode os.FileMode) error
	chmodMutex       sync.RWMutex
	chmodArgsForCall []struct {
		name string
		mode os.FileMode
	}
	chmodReturns struct {
		result1 error
	}
	ChtimesStub        func(name string, atime time.Time, mtime time.Time) error
	chtimesMutex       sync.RWMutex
	chtimesArgsForCall []struct {
		name  string
		atime time.Time
		mtime time.Time
	}
	chtimesReturns struct {
		result1 error
	}
	PipeStub        func() (r osshim.File, w osshim.File, err error)
	pipeMutex       sync.RWMutex
	pipeArgsForCall []struct{}
	pipeReturns     struct {
		result1 osshim.File
		result2 osshim.File
		result3 error
	}
	LinkStub        func(oldname, newname string) error
	linkMutex       sync.RWMutex
	linkArgsForCall []struct {
		oldname string
		newname string
	}
	linkReturns struct {
		result1 error
	}
	SymlinkStub        func(oldname, newname string) error
	symlinkMutex       sync.RWMutex
	symlinkArgsForCall []struct {
		oldname string
		newname string
	}
	symlinkReturns struct {
		result1 error
	}
	ReadlinkStub        func(name string) (string, error)
	readlinkMutex       sync.RWMutex
	readlinkArgsForCall []struct {
		name string
	}
	readlinkReturns struct {
		result1 string
		result2 error
	}
	ChownStub        func(name string, uid, gid int) error
	chownMutex       sync.RWMutex
	chownArgsForCall []struct {
		name string
		uid  int
		gid  int
	}
	chownReturns struct {
		result1 error
	}
	LchownStub        func(name string, uid, gid int) error
	lchownMutex       sync.RWMutex
	lchownArgsForCall []struct {
		name string
		uid  int
		gid  int
	}
	lchownReturns struct {
		result1 error
	}
	TempDirStub        func() string
	tempDirMutex       sync.RWMutex
	tempDirArgsForCall []struct{}
	tempDirReturns     struct {
		result1 string
	}
	StatStub        func(name string) (os.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		name string
	}
	statReturns struct {
		result1 os.FileInfo
		result2 error
	}
	LstatStub        func(name string) (os.FileInfo, error)
	lstatMutex       sync.RWMutex
	lstatArgsForCall []struct {
		name string
	}
	lstatReturns struct {
		result1 os.FileInfo
		result2 error
	}
	GetwdStub        func() (dir string, err error)
	getwdMutex       sync.RWMutex
	getwdArgsForCall []struct{}
	getwdReturns     struct {
		result1 string
		result2 error
	}
	MkdirAllStub        func(path string, perm os.FileMode) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		path string
		perm os.FileMode
	}
	mkdirAllReturns struct {
		result1 error
	}
	RemoveAllStub        func(path string) error
	removeAllMutex       sync.RWMutex
	removeAllArgsForCall []struct {
		path string
	}
	removeAllReturns struct {
		result1 error
	}
	IsPathSeparatorStub        func(c uint8) bool
	isPathSeparatorMutex       sync.RWMutex
	isPathSeparatorArgsForCall []struct {
		c uint8
	}
	isPathSeparatorReturns struct {
		result1 bool
	}
	GetuidStub        func() int
	getuidMutex       sync.RWMutex
	getuidArgsForCall []struct{}
	getuidReturns     struct {
		result1 int
	}
	GeteuidStub        func() int
	geteuidMutex       sync.RWMutex
	geteuidArgsForCall []struct{}
	geteuidReturns     struct {
		result1 int
	}
	GetgidStub        func() int
	getgidMutex       sync.RWMutex
	getgidArgsForCall []struct{}
	getgidReturns     struct {
		result1 int
	}
	GetegidStub        func() int
	getegidMutex       sync.RWMutex
	getegidArgsForCall []struct{}
	getegidReturns     struct {
		result1 int
	}
	GetgroupsStub        func() ([]int, error)
	getgroupsMutex       sync.RWMutex
	getgroupsArgsForCall []struct{}
	getgroupsReturns     struct {
		result1 []int
		result2 error
	}
	ExitStub        func(code int)
	exitMutex       sync.RWMutex
	exitArgsForCall []struct {
		code int
	}
	GetpagesizeStub        func() int
	getpagesizeMutex       sync.RWMutex
	getpagesizeArgsForCall []struct{}
	getpagesizeReturns     struct {
		result1 int
	}
	SameFileStub        func(fi1, fi2 os.FileInfo) bool
	sameFileMutex       sync.RWMutex
	sameFileArgsForCall []struct {
		fi1 os.FileInfo
		fi2 os.FileInfo
	}
	sameFileReturns struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOs) FindProcess(pid int) (*os.Process, error) {
	fake.findProcessMutex.Lock()
	fake.findProcessArgsForCall = append(fake.findProcessArgsForCall, struct {
		pid int
	}{pid})
	fake.recordInvocation("FindProcess", []interface{}{pid})
	fake.findProcessMutex.Unlock()
	if fake.FindProcessStub != nil {
		return fake.FindProcessStub(pid)
	}
	return fake.findProcessReturns.result1, fake.findProcessReturns.result2
}

func (fake *FakeOs) FindProcessCallCount() int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	return len(fake.findProcessArgsForCall)
}

func (fake *FakeOs) FindProcessArgsForCall(i int) int {
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	return fake.findProcessArgsForCall[i].pid
}

func (fake *FakeOs) FindProcessReturns(result1 *os.Process, result2 error) {
	fake.FindProcessStub = nil
	fake.findProcessReturns = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) StartProcess(name string, argv []string, attr *os.ProcAttr) (*os.Process, error) {
	var argvCopy []string
	if argv != nil {
		argvCopy = make([]string, len(argv))
		copy(argvCopy, argv)
	}
	fake.startProcessMutex.Lock()
	fake.startProcessArgsForCall = append(fake.startProcessArgsForCall, struct {
		name string
		argv []string
		attr *os.ProcAttr
	}{name, argvCopy, attr})
	fake.recordInvocation("StartProcess", []interface{}{name, argvCopy, attr})
	fake.startProcessMutex.Unlock()
	if fake.StartProcessStub != nil {
		return fake.StartProcessStub(name, argv, attr)
	}
	return fake.startProcessReturns.result1, fake.startProcessReturns.result2
}

func (fake *FakeOs) StartProcessCallCount() int {
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	return len(fake.startProcessArgsForCall)
}

func (fake *FakeOs) StartProcessArgsForCall(i int) (string, []string, *os.ProcAttr) {
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	return fake.startProcessArgsForCall[i].name, fake.startProcessArgsForCall[i].argv, fake.startProcessArgsForCall[i].attr
}

func (fake *FakeOs) StartProcessReturns(result1 *os.Process, result2 error) {
	fake.StartProcessStub = nil
	fake.startProcessReturns = struct {
		result1 *os.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Hostname() (name string, err error) {
	fake.hostnameMutex.Lock()
	fake.hostnameArgsForCall = append(fake.hostnameArgsForCall, struct{}{})
	fake.recordInvocation("Hostname", []interface{}{})
	fake.hostnameMutex.Unlock()
	if fake.HostnameStub != nil {
		return fake.HostnameStub()
	}
	return fake.hostnameReturns.result1, fake.hostnameReturns.result2
}

func (fake *FakeOs) HostnameCallCount() int {
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	return len(fake.hostnameArgsForCall)
}

func (fake *FakeOs) HostnameReturns(result1 string, result2 error) {
	fake.HostnameStub = nil
	fake.hostnameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Expand(s string, mapping func(string) string) string {
	fake.expandMutex.Lock()
	fake.expandArgsForCall = append(fake.expandArgsForCall, struct {
		s       string
		mapping func(string) string
	}{s, mapping})
	fake.recordInvocation("Expand", []interface{}{s, mapping})
	fake.expandMutex.Unlock()
	if fake.ExpandStub != nil {
		return fake.ExpandStub(s, mapping)
	}
	return fake.expandReturns.result1
}

func (fake *FakeOs) ExpandCallCount() int {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	return len(fake.expandArgsForCall)
}

func (fake *FakeOs) ExpandArgsForCall(i int) (string, func(string) string) {
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	return fake.expandArgsForCall[i].s, fake.expandArgsForCall[i].mapping
}

func (fake *FakeOs) ExpandReturns(result1 string) {
	fake.ExpandStub = nil
	fake.expandReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) ExpandEnv(s string) string {
	fake.expandEnvMutex.Lock()
	fake.expandEnvArgsForCall = append(fake.expandEnvArgsForCall, struct {
		s string
	}{s})
	fake.recordInvocation("ExpandEnv", []interface{}{s})
	fake.expandEnvMutex.Unlock()
	if fake.ExpandEnvStub != nil {
		return fake.ExpandEnvStub(s)
	}
	return fake.expandEnvReturns.result1
}

func (fake *FakeOs) ExpandEnvCallCount() int {
	fake.expandEnvMutex.RLock()
	defer fake.expandEnvMutex.RUnlock()
	return len(fake.expandEnvArgsForCall)
}

func (fake *FakeOs) ExpandEnvArgsForCall(i int) string {
	fake.expandEnvMutex.RLock()
	defer fake.expandEnvMutex.RUnlock()
	return fake.expandEnvArgsForCall[i].s
}

func (fake *FakeOs) ExpandEnvReturns(result1 string) {
	fake.ExpandEnvStub = nil
	fake.expandEnvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) Getenv(key string) string {
	fake.getenvMutex.Lock()
	fake.getenvArgsForCall = append(fake.getenvArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("Getenv", []interface{}{key})
	fake.getenvMutex.Unlock()
	if fake.GetenvStub != nil {
		return fake.GetenvStub(key)
	}
	return fake.getenvReturns.result1
}

func (fake *FakeOs) GetenvCallCount() int {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return len(fake.getenvArgsForCall)
}

func (fake *FakeOs) GetenvArgsForCall(i int) string {
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	return fake.getenvArgsForCall[i].key
}

func (fake *FakeOs) GetenvReturns(result1 string) {
	fake.GetenvStub = nil
	fake.getenvReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) LookupEnv(key string) (string, bool) {
	fake.lookupEnvMutex.Lock()
	fake.lookupEnvArgsForCall = append(fake.lookupEnvArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("LookupEnv", []interface{}{key})
	fake.lookupEnvMutex.Unlock()
	if fake.LookupEnvStub != nil {
		return fake.LookupEnvStub(key)
	}
	return fake.lookupEnvReturns.result1, fake.lookupEnvReturns.result2
}

func (fake *FakeOs) LookupEnvCallCount() int {
	fake.lookupEnvMutex.RLock()
	defer fake.lookupEnvMutex.RUnlock()
	return len(fake.lookupEnvArgsForCall)
}

func (fake *FakeOs) LookupEnvArgsForCall(i int) string {
	fake.lookupEnvMutex.RLock()
	defer fake.lookupEnvMutex.RUnlock()
	return fake.lookupEnvArgsForCall[i].key
}

func (fake *FakeOs) LookupEnvReturns(result1 string, result2 bool) {
	fake.LookupEnvStub = nil
	fake.lookupEnvReturns = struct {
		result1 string
		result2 bool
	}{result1, result2}
}

func (fake *FakeOs) Setenv(key string, value string) error {
	fake.setenvMutex.Lock()
	fake.setenvArgsForCall = append(fake.setenvArgsForCall, struct {
		key   string
		value string
	}{key, value})
	fake.recordInvocation("Setenv", []interface{}{key, value})
	fake.setenvMutex.Unlock()
	if fake.SetenvStub != nil {
		return fake.SetenvStub(key, value)
	}
	return fake.setenvReturns.result1
}

func (fake *FakeOs) SetenvCallCount() int {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	return len(fake.setenvArgsForCall)
}

func (fake *FakeOs) SetenvArgsForCall(i int) (string, string) {
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	return fake.setenvArgsForCall[i].key, fake.setenvArgsForCall[i].value
}

func (fake *FakeOs) SetenvReturns(result1 error) {
	fake.SetenvStub = nil
	fake.setenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Unsetenv(key string) error {
	fake.unsetenvMutex.Lock()
	fake.unsetenvArgsForCall = append(fake.unsetenvArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("Unsetenv", []interface{}{key})
	fake.unsetenvMutex.Unlock()
	if fake.UnsetenvStub != nil {
		return fake.UnsetenvStub(key)
	}
	return fake.unsetenvReturns.result1
}

func (fake *FakeOs) UnsetenvCallCount() int {
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	return len(fake.unsetenvArgsForCall)
}

func (fake *FakeOs) UnsetenvArgsForCall(i int) string {
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	return fake.unsetenvArgsForCall[i].key
}

func (fake *FakeOs) UnsetenvReturns(result1 error) {
	fake.UnsetenvStub = nil
	fake.unsetenvReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Clearenv() {
	fake.clearenvMutex.Lock()
	fake.clearenvArgsForCall = append(fake.clearenvArgsForCall, struct{}{})
	fake.recordInvocation("Clearenv", []interface{}{})
	fake.clearenvMutex.Unlock()
	if fake.ClearenvStub != nil {
		fake.ClearenvStub()
	}
}

func (fake *FakeOs) ClearenvCallCount() int {
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	return len(fake.clearenvArgsForCall)
}

func (fake *FakeOs) Environ() []string {
	fake.environMutex.Lock()
	fake.environArgsForCall = append(fake.environArgsForCall, struct{}{})
	fake.recordInvocation("Environ", []interface{}{})
	fake.environMutex.Unlock()
	if fake.EnvironStub != nil {
		return fake.EnvironStub()
	}
	return fake.environReturns.result1
}

func (fake *FakeOs) EnvironCallCount() int {
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	return len(fake.environArgsForCall)
}

func (fake *FakeOs) EnvironReturns(result1 []string) {
	fake.EnvironStub = nil
	fake.environReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeOs) NewSyscallError(syscall string, err error) error {
	fake.newSyscallErrorMutex.Lock()
	fake.newSyscallErrorArgsForCall = append(fake.newSyscallErrorArgsForCall, struct {
		syscall string
		err     error
	}{syscall, err})
	fake.recordInvocation("NewSyscallError", []interface{}{syscall, err})
	fake.newSyscallErrorMutex.Unlock()
	if fake.NewSyscallErrorStub != nil {
		return fake.NewSyscallErrorStub(syscall, err)
	}
	return fake.newSyscallErrorReturns.result1
}

func (fake *FakeOs) NewSyscallErrorCallCount() int {
	fake.newSyscallErrorMutex.RLock()
	defer fake.newSyscallErrorMutex.RUnlock()
	return len(fake.newSyscallErrorArgsForCall)
}

func (fake *FakeOs) NewSyscallErrorArgsForCall(i int) (string, error) {
	fake.newSyscallErrorMutex.RLock()
	defer fake.newSyscallErrorMutex.RUnlock()
	return fake.newSyscallErrorArgsForCall[i].syscall, fake.newSyscallErrorArgsForCall[i].err
}

func (fake *FakeOs) NewSyscallErrorReturns(result1 error) {
	fake.NewSyscallErrorStub = nil
	fake.newSyscallErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) IsExist(err error) bool {
	fake.isExistMutex.Lock()
	fake.isExistArgsForCall = append(fake.isExistArgsForCall, struct {
		err error
	}{err})
	fake.recordInvocation("IsExist", []interface{}{err})
	fake.isExistMutex.Unlock()
	if fake.IsExistStub != nil {
		return fake.IsExistStub(err)
	}
	return fake.isExistReturns.result1
}

func (fake *FakeOs) IsExistCallCount() int {
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	return len(fake.isExistArgsForCall)
}

func (fake *FakeOs) IsExistArgsForCall(i int) error {
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	return fake.isExistArgsForCall[i].err
}

func (fake *FakeOs) IsExistReturns(result1 bool) {
	fake.IsExistStub = nil
	fake.isExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsNotExist(err error) bool {
	fake.isNotExistMutex.Lock()
	fake.isNotExistArgsForCall = append(fake.isNotExistArgsForCall, struct {
		err error
	}{err})
	fake.recordInvocation("IsNotExist", []interface{}{err})
	fake.isNotExistMutex.Unlock()
	if fake.IsNotExistStub != nil {
		return fake.IsNotExistStub(err)
	}
	return fake.isNotExistReturns.result1
}

func (fake *FakeOs) IsNotExistCallCount() int {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	return len(fake.isNotExistArgsForCall)
}

func (fake *FakeOs) IsNotExistArgsForCall(i int) error {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	return fake.isNotExistArgsForCall[i].err
}

func (fake *FakeOs) IsNotExistReturns(result1 bool) {
	fake.IsNotExistStub = nil
	fake.isNotExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) IsPermission(err error) bool {
	fake.isPermissionMutex.Lock()
	fake.isPermissionArgsForCall = append(fake.isPermissionArgsForCall, struct {
		err error
	}{err})
	fake.recordInvocation("IsPermission", []interface{}{err})
	fake.isPermissionMutex.Unlock()
	if fake.IsPermissionStub != nil {
		return fake.IsPermissionStub(err)
	}
	return fake.isPermissionReturns.result1
}

func (fake *FakeOs) IsPermissionCallCount() int {
	fake.isPermissionMutex.RLock()
	defer fake.isPermissionMutex.RUnlock()
	return len(fake.isPermissionArgsForCall)
}

func (fake *FakeOs) IsPermissionArgsForCall(i int) error {
	fake.isPermissionMutex.RLock()
	defer fake.isPermissionMutex.RUnlock()
	return fake.isPermissionArgsForCall[i].err
}

func (fake *FakeOs) IsPermissionReturns(result1 bool) {
	fake.IsPermissionStub = nil
	fake.isPermissionReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) Getpid() int {
	fake.getpidMutex.Lock()
	fake.getpidArgsForCall = append(fake.getpidArgsForCall, struct{}{})
	fake.recordInvocation("Getpid", []interface{}{})
	fake.getpidMutex.Unlock()
	if fake.GetpidStub != nil {
		return fake.GetpidStub()
	}
	return fake.getpidReturns.result1
}

func (fake *FakeOs) GetpidCallCount() int {
	fake.getpidMutex.RLock()
	defer fake.getpidMutex.RUnlock()
	return len(fake.getpidArgsForCall)
}

func (fake *FakeOs) GetpidReturns(result1 int) {
	fake.GetpidStub = nil
	fake.getpidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getppid() int {
	fake.getppidMutex.Lock()
	fake.getppidArgsForCall = append(fake.getppidArgsForCall, struct{}{})
	fake.recordInvocation("Getppid", []interface{}{})
	fake.getppidMutex.Unlock()
	if fake.GetppidStub != nil {
		return fake.GetppidStub()
	}
	return fake.getppidReturns.result1
}

func (fake *FakeOs) GetppidCallCount() int {
	fake.getppidMutex.RLock()
	defer fake.getppidMutex.RUnlock()
	return len(fake.getppidArgsForCall)
}

func (fake *FakeOs) GetppidReturns(result1 int) {
	fake.GetppidStub = nil
	fake.getppidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Mkdir(name string, perm os.FileMode) error {
	fake.mkdirMutex.Lock()
	fake.mkdirArgsForCall = append(fake.mkdirArgsForCall, struct {
		name string
		perm os.FileMode
	}{name, perm})
	fake.recordInvocation("Mkdir", []interface{}{name, perm})
	fake.mkdirMutex.Unlock()
	if fake.MkdirStub != nil {
		return fake.MkdirStub(name, perm)
	}
	return fake.mkdirReturns.result1
}

func (fake *FakeOs) MkdirCallCount() int {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return len(fake.mkdirArgsForCall)
}

func (fake *FakeOs) MkdirArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return fake.mkdirArgsForCall[i].name, fake.mkdirArgsForCall[i].perm
}

func (fake *FakeOs) MkdirReturns(result1 error) {
	fake.MkdirStub = nil
	fake.mkdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Chdir(dir string) error {
	fake.chdirMutex.Lock()
	fake.chdirArgsForCall = append(fake.chdirArgsForCall, struct {
		dir string
	}{dir})
	fake.recordInvocation("Chdir", []interface{}{dir})
	fake.chdirMutex.Unlock()
	if fake.ChdirStub != nil {
		return fake.ChdirStub(dir)
	}
	return fake.chdirReturns.result1
}

func (fake *FakeOs) ChdirCallCount() int {
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	return len(fake.chdirArgsForCall)
}

func (fake *FakeOs) ChdirArgsForCall(i int) string {
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	return fake.chdirArgsForCall[i].dir
}

func (fake *FakeOs) ChdirReturns(result1 error) {
	fake.ChdirStub = nil
	fake.chdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Open(name string) (osshim.File, error) {
	fake.openMutex.Lock()
	fake.openArgsForCall = append(fake.openArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Open", []interface{}{name})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub(name)
	}
	return fake.openReturns.result1, fake.openReturns.result2
}

func (fake *FakeOs) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeOs) OpenArgsForCall(i int) string {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return fake.openArgsForCall[i].name
}

func (fake *FakeOs) OpenReturns(result1 osshim.File, result2 error) {
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 osshim.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Create(name string) (osshim.File, error) {
	fake.createMutex.Lock()
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Create", []interface{}{name})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(name)
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeOs) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeOs) CreateArgsForCall(i int) string {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].name
}

func (fake *FakeOs) CreateReturns(result1 osshim.File, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 osshim.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Rename(oldpath string, newpath string) error {
	fake.renameMutex.Lock()
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		oldpath string
		newpath string
	}{oldpath, newpath})
	fake.recordInvocation("Rename", []interface{}{oldpath, newpath})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(oldpath, newpath)
	}
	return fake.renameReturns.result1
}

func (fake *FakeOs) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeOs) RenameArgsForCall(i int) (string, string) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return fake.renameArgsForCall[i].oldpath, fake.renameArgsForCall[i].newpath
}

func (fake *FakeOs) RenameReturns(result1 error) {
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) NewFile(fd uintptr, name string) osshim.File {
	fake.newFileMutex.Lock()
	fake.newFileArgsForCall = append(fake.newFileArgsForCall, struct {
		fd   uintptr
		name string
	}{fd, name})
	fake.recordInvocation("NewFile", []interface{}{fd, name})
	fake.newFileMutex.Unlock()
	if fake.NewFileStub != nil {
		return fake.NewFileStub(fd, name)
	}
	return fake.newFileReturns.result1
}

func (fake *FakeOs) NewFileCallCount() int {
	fake.newFileMutex.RLock()
	defer fake.newFileMutex.RUnlock()
	return len(fake.newFileArgsForCall)
}

func (fake *FakeOs) NewFileArgsForCall(i int) (uintptr, string) {
	fake.newFileMutex.RLock()
	defer fake.newFileMutex.RUnlock()
	return fake.newFileArgsForCall[i].fd, fake.newFileArgsForCall[i].name
}

func (fake *FakeOs) NewFileReturns(result1 osshim.File) {
	fake.NewFileStub = nil
	fake.newFileReturns = struct {
		result1 osshim.File
	}{result1}
}

func (fake *FakeOs) OpenFile(name string, flag int, perm os.FileMode) (osshim.File, error) {
	fake.openFileMutex.Lock()
	fake.openFileArgsForCall = append(fake.openFileArgsForCall, struct {
		name string
		flag int
		perm os.FileMode
	}{name, flag, perm})
	fake.recordInvocation("OpenFile", []interface{}{name, flag, perm})
	fake.openFileMutex.Unlock()
	if fake.OpenFileStub != nil {
		return fake.OpenFileStub(name, flag, perm)
	}
	return fake.openFileReturns.result1, fake.openFileReturns.result2
}

func (fake *FakeOs) OpenFileCallCount() int {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	return len(fake.openFileArgsForCall)
}

func (fake *FakeOs) OpenFileArgsForCall(i int) (string, int, os.FileMode) {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	return fake.openFileArgsForCall[i].name, fake.openFileArgsForCall[i].flag, fake.openFileArgsForCall[i].perm
}

func (fake *FakeOs) OpenFileReturns(result1 osshim.File, result2 error) {
	fake.OpenFileStub = nil
	fake.openFileReturns = struct {
		result1 osshim.File
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Truncate(name string, size int64) error {
	fake.truncateMutex.Lock()
	fake.truncateArgsForCall = append(fake.truncateArgsForCall, struct {
		name string
		size int64
	}{name, size})
	fake.recordInvocation("Truncate", []interface{}{name, size})
	fake.truncateMutex.Unlock()
	if fake.TruncateStub != nil {
		return fake.TruncateStub(name, size)
	}
	return fake.truncateReturns.result1
}

func (fake *FakeOs) TruncateCallCount() int {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return len(fake.truncateArgsForCall)
}

func (fake *FakeOs) TruncateArgsForCall(i int) (string, int64) {
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	return fake.truncateArgsForCall[i].name, fake.truncateArgsForCall[i].size
}

func (fake *FakeOs) TruncateReturns(result1 error) {
	fake.TruncateStub = nil
	fake.truncateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Remove(name string) error {
	fake.removeMutex.Lock()
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Remove", []interface{}{name})
	fake.removeMutex.Unlock()
	if fake.RemoveStub != nil {
		return fake.RemoveStub(name)
	}
	return fake.removeReturns.result1
}

func (fake *FakeOs) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeOs) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return fake.removeArgsForCall[i].name
}

func (fake *FakeOs) RemoveReturns(result1 error) {
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Chmod(name string, mode os.FileMode) error {
	fake.chmodMutex.Lock()
	fake.chmodArgsForCall = append(fake.chmodArgsForCall, struct {
		name string
		mode os.FileMode
	}{name, mode})
	fake.recordInvocation("Chmod", []interface{}{name, mode})
	fake.chmodMutex.Unlock()
	if fake.ChmodStub != nil {
		return fake.ChmodStub(name, mode)
	}
	return fake.chmodReturns.result1
}

func (fake *FakeOs) ChmodCallCount() int {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return len(fake.chmodArgsForCall)
}

func (fake *FakeOs) ChmodArgsForCall(i int) (string, os.FileMode) {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return fake.chmodArgsForCall[i].name, fake.chmodArgsForCall[i].mode
}

func (fake *FakeOs) ChmodReturns(result1 error) {
	fake.ChmodStub = nil
	fake.chmodReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Chtimes(name string, atime time.Time, mtime time.Time) error {
	fake.chtimesMutex.Lock()
	fake.chtimesArgsForCall = append(fake.chtimesArgsForCall, struct {
		name  string
		atime time.Time
		mtime time.Time
	}{name, atime, mtime})
	fake.recordInvocation("Chtimes", []interface{}{name, atime, mtime})
	fake.chtimesMutex.Unlock()
	if fake.ChtimesStub != nil {
		return fake.ChtimesStub(name, atime, mtime)
	}
	return fake.chtimesReturns.result1
}

func (fake *FakeOs) ChtimesCallCount() int {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	return len(fake.chtimesArgsForCall)
}

func (fake *FakeOs) ChtimesArgsForCall(i int) (string, time.Time, time.Time) {
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	return fake.chtimesArgsForCall[i].name, fake.chtimesArgsForCall[i].atime, fake.chtimesArgsForCall[i].mtime
}

func (fake *FakeOs) ChtimesReturns(result1 error) {
	fake.ChtimesStub = nil
	fake.chtimesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Pipe() (r osshim.File, w osshim.File, err error) {
	fake.pipeMutex.Lock()
	fake.pipeArgsForCall = append(fake.pipeArgsForCall, struct{}{})
	fake.recordInvocation("Pipe", []interface{}{})
	fake.pipeMutex.Unlock()
	if fake.PipeStub != nil {
		return fake.PipeStub()
	}
	return fake.pipeReturns.result1, fake.pipeReturns.result2, fake.pipeReturns.result3
}

func (fake *FakeOs) PipeCallCount() int {
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	return len(fake.pipeArgsForCall)
}

func (fake *FakeOs) PipeReturns(result1 osshim.File, result2 osshim.File, result3 error) {
	fake.PipeStub = nil
	fake.pipeReturns = struct {
		result1 osshim.File
		result2 osshim.File
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeOs) Link(oldname string, newname string) error {
	fake.linkMutex.Lock()
	fake.linkArgsForCall = append(fake.linkArgsForCall, struct {
		oldname string
		newname string
	}{oldname, newname})
	fake.recordInvocation("Link", []interface{}{oldname, newname})
	fake.linkMutex.Unlock()
	if fake.LinkStub != nil {
		return fake.LinkStub(oldname, newname)
	}
	return fake.linkReturns.result1
}

func (fake *FakeOs) LinkCallCount() int {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return len(fake.linkArgsForCall)
}

func (fake *FakeOs) LinkArgsForCall(i int) (string, string) {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return fake.linkArgsForCall[i].oldname, fake.linkArgsForCall[i].newname
}

func (fake *FakeOs) LinkReturns(result1 error) {
	fake.LinkStub = nil
	fake.linkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Symlink(oldname string, newname string) error {
	fake.symlinkMutex.Lock()
	fake.symlinkArgsForCall = append(fake.symlinkArgsForCall, struct {
		oldname string
		newname string
	}{oldname, newname})
	fake.recordInvocation("Symlink", []interface{}{oldname, newname})
	fake.symlinkMutex.Unlock()
	if fake.SymlinkStub != nil {
		return fake.SymlinkStub(oldname, newname)
	}
	return fake.symlinkReturns.result1
}

func (fake *FakeOs) SymlinkCallCount() int {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return len(fake.symlinkArgsForCall)
}

func (fake *FakeOs) SymlinkArgsForCall(i int) (string, string) {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return fake.symlinkArgsForCall[i].oldname, fake.symlinkArgsForCall[i].newname
}

func (fake *FakeOs) SymlinkReturns(result1 error) {
	fake.SymlinkStub = nil
	fake.symlinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Readlink(name string) (string, error) {
	fake.readlinkMutex.Lock()
	fake.readlinkArgsForCall = append(fake.readlinkArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Readlink", []interface{}{name})
	fake.readlinkMutex.Unlock()
	if fake.ReadlinkStub != nil {
		return fake.ReadlinkStub(name)
	}
	return fake.readlinkReturns.result1, fake.readlinkReturns.result2
}

func (fake *FakeOs) ReadlinkCallCount() int {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return len(fake.readlinkArgsForCall)
}

func (fake *FakeOs) ReadlinkArgsForCall(i int) string {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return fake.readlinkArgsForCall[i].name
}

func (fake *FakeOs) ReadlinkReturns(result1 string, result2 error) {
	fake.ReadlinkStub = nil
	fake.readlinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Chown(name string, uid int, gid int) error {
	fake.chownMutex.Lock()
	fake.chownArgsForCall = append(fake.chownArgsForCall, struct {
		name string
		uid  int
		gid  int
	}{name, uid, gid})
	fake.recordInvocation("Chown", []interface{}{name, uid, gid})
	fake.chownMutex.Unlock()
	if fake.ChownStub != nil {
		return fake.ChownStub(name, uid, gid)
	}
	return fake.chownReturns.result1
}

func (fake *FakeOs) ChownCallCount() int {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return len(fake.chownArgsForCall)
}

func (fake *FakeOs) ChownArgsForCall(i int) (string, int, int) {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return fake.chownArgsForCall[i].name, fake.chownArgsForCall[i].uid, fake.chownArgsForCall[i].gid
}

func (fake *FakeOs) ChownReturns(result1 error) {
	fake.ChownStub = nil
	fake.chownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) Lchown(name string, uid int, gid int) error {
	fake.lchownMutex.Lock()
	fake.lchownArgsForCall = append(fake.lchownArgsForCall, struct {
		name string
		uid  int
		gid  int
	}{name, uid, gid})
	fake.recordInvocation("Lchown", []interface{}{name, uid, gid})
	fake.lchownMutex.Unlock()
	if fake.LchownStub != nil {
		return fake.LchownStub(name, uid, gid)
	}
	return fake.lchownReturns.result1
}

func (fake *FakeOs) LchownCallCount() int {
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	return len(fake.lchownArgsForCall)
}

func (fake *FakeOs) LchownArgsForCall(i int) (string, int, int) {
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	return fake.lchownArgsForCall[i].name, fake.lchownArgsForCall[i].uid, fake.lchownArgsForCall[i].gid
}

func (fake *FakeOs) LchownReturns(result1 error) {
	fake.LchownStub = nil
	fake.lchownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) TempDir() string {
	fake.tempDirMutex.Lock()
	fake.tempDirArgsForCall = append(fake.tempDirArgsForCall, struct{}{})
	fake.recordInvocation("TempDir", []interface{}{})
	fake.tempDirMutex.Unlock()
	if fake.TempDirStub != nil {
		return fake.TempDirStub()
	}
	return fake.tempDirReturns.result1
}

func (fake *FakeOs) TempDirCallCount() int {
	fake.tempDirMutex.RLock()
	defer fake.tempDirMutex.RUnlock()
	return len(fake.tempDirArgsForCall)
}

func (fake *FakeOs) TempDirReturns(result1 string) {
	fake.TempDirStub = nil
	fake.tempDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeOs) Stat(name string) (os.FileInfo, error) {
	fake.statMutex.Lock()
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Stat", []interface{}{name})
	fake.statMutex.Unlock()
	if fake.StatStub != nil {
		return fake.StatStub(name)
	}
	return fake.statReturns.result1, fake.statReturns.result2
}

func (fake *FakeOs) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeOs) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return fake.statArgsForCall[i].name
}

func (fake *FakeOs) StatReturns(result1 os.FileInfo, result2 error) {
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Lstat(name string) (os.FileInfo, error) {
	fake.lstatMutex.Lock()
	fake.lstatArgsForCall = append(fake.lstatArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Lstat", []interface{}{name})
	fake.lstatMutex.Unlock()
	if fake.LstatStub != nil {
		return fake.LstatStub(name)
	}
	return fake.lstatReturns.result1, fake.lstatReturns.result2
}

func (fake *FakeOs) LstatCallCount() int {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	return len(fake.lstatArgsForCall)
}

func (fake *FakeOs) LstatArgsForCall(i int) string {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	return fake.lstatArgsForCall[i].name
}

func (fake *FakeOs) LstatReturns(result1 os.FileInfo, result2 error) {
	fake.LstatStub = nil
	fake.lstatReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Getwd() (dir string, err error) {
	fake.getwdMutex.Lock()
	fake.getwdArgsForCall = append(fake.getwdArgsForCall, struct{}{})
	fake.recordInvocation("Getwd", []interface{}{})
	fake.getwdMutex.Unlock()
	if fake.GetwdStub != nil {
		return fake.GetwdStub()
	}
	return fake.getwdReturns.result1, fake.getwdReturns.result2
}

func (fake *FakeOs) GetwdCallCount() int {
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	return len(fake.getwdArgsForCall)
}

func (fake *FakeOs) GetwdReturns(result1 string, result2 error) {
	fake.GetwdStub = nil
	fake.getwdReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) MkdirAll(path string, perm os.FileMode) error {
	fake.mkdirAllMutex.Lock()
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		path string
		perm os.FileMode
	}{path, perm})
	fake.recordInvocation("MkdirAll", []interface{}{path, perm})
	fake.mkdirAllMutex.Unlock()
	if fake.MkdirAllStub != nil {
		return fake.MkdirAllStub(path, perm)
	}
	return fake.mkdirAllReturns.result1
}

func (fake *FakeOs) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakeOs) MkdirAllArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return fake.mkdirAllArgsForCall[i].path, fake.mkdirAllArgsForCall[i].perm
}

func (fake *FakeOs) MkdirAllReturns(result1 error) {
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) RemoveAll(path string) error {
	fake.removeAllMutex.Lock()
	fake.removeAllArgsForCall = append(fake.removeAllArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("RemoveAll", []interface{}{path})
	fake.removeAllMutex.Unlock()
	if fake.RemoveAllStub != nil {
		return fake.RemoveAllStub(path)
	}
	return fake.removeAllReturns.result1
}

func (fake *FakeOs) RemoveAllCallCount() int {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return len(fake.removeAllArgsForCall)
}

func (fake *FakeOs) RemoveAllArgsForCall(i int) string {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return fake.removeAllArgsForCall[i].path
}

func (fake *FakeOs) RemoveAllReturns(result1 error) {
	fake.RemoveAllStub = nil
	fake.removeAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOs) IsPathSeparator(c uint8) bool {
	fake.isPathSeparatorMutex.Lock()
	fake.isPathSeparatorArgsForCall = append(fake.isPathSeparatorArgsForCall, struct {
		c uint8
	}{c})
	fake.recordInvocation("IsPathSeparator", []interface{}{c})
	fake.isPathSeparatorMutex.Unlock()
	if fake.IsPathSeparatorStub != nil {
		return fake.IsPathSeparatorStub(c)
	}
	return fake.isPathSeparatorReturns.result1
}

func (fake *FakeOs) IsPathSeparatorCallCount() int {
	fake.isPathSeparatorMutex.RLock()
	defer fake.isPathSeparatorMutex.RUnlock()
	return len(fake.isPathSeparatorArgsForCall)
}

func (fake *FakeOs) IsPathSeparatorArgsForCall(i int) uint8 {
	fake.isPathSeparatorMutex.RLock()
	defer fake.isPathSeparatorMutex.RUnlock()
	return fake.isPathSeparatorArgsForCall[i].c
}

func (fake *FakeOs) IsPathSeparatorReturns(result1 bool) {
	fake.IsPathSeparatorStub = nil
	fake.isPathSeparatorReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) Getuid() int {
	fake.getuidMutex.Lock()
	fake.getuidArgsForCall = append(fake.getuidArgsForCall, struct{}{})
	fake.recordInvocation("Getuid", []interface{}{})
	fake.getuidMutex.Unlock()
	if fake.GetuidStub != nil {
		return fake.GetuidStub()
	}
	return fake.getuidReturns.result1
}

func (fake *FakeOs) GetuidCallCount() int {
	fake.getuidMutex.RLock()
	defer fake.getuidMutex.RUnlock()
	return len(fake.getuidArgsForCall)
}

func (fake *FakeOs) GetuidReturns(result1 int) {
	fake.GetuidStub = nil
	fake.getuidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Geteuid() int {
	fake.geteuidMutex.Lock()
	fake.geteuidArgsForCall = append(fake.geteuidArgsForCall, struct{}{})
	fake.recordInvocation("Geteuid", []interface{}{})
	fake.geteuidMutex.Unlock()
	if fake.GeteuidStub != nil {
		return fake.GeteuidStub()
	}
	return fake.geteuidReturns.result1
}

func (fake *FakeOs) GeteuidCallCount() int {
	fake.geteuidMutex.RLock()
	defer fake.geteuidMutex.RUnlock()
	return len(fake.geteuidArgsForCall)
}

func (fake *FakeOs) GeteuidReturns(result1 int) {
	fake.GeteuidStub = nil
	fake.geteuidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getgid() int {
	fake.getgidMutex.Lock()
	fake.getgidArgsForCall = append(fake.getgidArgsForCall, struct{}{})
	fake.recordInvocation("Getgid", []interface{}{})
	fake.getgidMutex.Unlock()
	if fake.GetgidStub != nil {
		return fake.GetgidStub()
	}
	return fake.getgidReturns.result1
}

func (fake *FakeOs) GetgidCallCount() int {
	fake.getgidMutex.RLock()
	defer fake.getgidMutex.RUnlock()
	return len(fake.getgidArgsForCall)
}

func (fake *FakeOs) GetgidReturns(result1 int) {
	fake.GetgidStub = nil
	fake.getgidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getegid() int {
	fake.getegidMutex.Lock()
	fake.getegidArgsForCall = append(fake.getegidArgsForCall, struct{}{})
	fake.recordInvocation("Getegid", []interface{}{})
	fake.getegidMutex.Unlock()
	if fake.GetegidStub != nil {
		return fake.GetegidStub()
	}
	return fake.getegidReturns.result1
}

func (fake *FakeOs) GetegidCallCount() int {
	fake.getegidMutex.RLock()
	defer fake.getegidMutex.RUnlock()
	return len(fake.getegidArgsForCall)
}

func (fake *FakeOs) GetegidReturns(result1 int) {
	fake.GetegidStub = nil
	fake.getegidReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) Getgroups() ([]int, error) {
	fake.getgroupsMutex.Lock()
	fake.getgroupsArgsForCall = append(fake.getgroupsArgsForCall, struct{}{})
	fake.recordInvocation("Getgroups", []interface{}{})
	fake.getgroupsMutex.Unlock()
	if fake.GetgroupsStub != nil {
		return fake.GetgroupsStub()
	}
	return fake.getgroupsReturns.result1, fake.getgroupsReturns.result2
}

func (fake *FakeOs) GetgroupsCallCount() int {
	fake.getgroupsMutex.RLock()
	defer fake.getgroupsMutex.RUnlock()
	return len(fake.getgroupsArgsForCall)
}

func (fake *FakeOs) GetgroupsReturns(result1 []int, result2 error) {
	fake.GetgroupsStub = nil
	fake.getgroupsReturns = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakeOs) Exit(code int) {
	fake.exitMutex.Lock()
	fake.exitArgsForCall = append(fake.exitArgsForCall, struct {
		code int
	}{code})
	fake.recordInvocation("Exit", []interface{}{code})
	fake.exitMutex.Unlock()
	if fake.ExitStub != nil {
		fake.ExitStub(code)
	}
}

func (fake *FakeOs) ExitCallCount() int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return len(fake.exitArgsForCall)
}

func (fake *FakeOs) ExitArgsForCall(i int) int {
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	return fake.exitArgsForCall[i].code
}

func (fake *FakeOs) Getpagesize() int {
	fake.getpagesizeMutex.Lock()
	fake.getpagesizeArgsForCall = append(fake.getpagesizeArgsForCall, struct{}{})
	fake.recordInvocation("Getpagesize", []interface{}{})
	fake.getpagesizeMutex.Unlock()
	if fake.GetpagesizeStub != nil {
		return fake.GetpagesizeStub()
	}
	return fake.getpagesizeReturns.result1
}

func (fake *FakeOs) GetpagesizeCallCount() int {
	fake.getpagesizeMutex.RLock()
	defer fake.getpagesizeMutex.RUnlock()
	return len(fake.getpagesizeArgsForCall)
}

func (fake *FakeOs) GetpagesizeReturns(result1 int) {
	fake.GetpagesizeStub = nil
	fake.getpagesizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeOs) SameFile(fi1 os.FileInfo, fi2 os.FileInfo) bool {
	fake.sameFileMutex.Lock()
	fake.sameFileArgsForCall = append(fake.sameFileArgsForCall, struct {
		fi1 os.FileInfo
		fi2 os.FileInfo
	}{fi1, fi2})
	fake.recordInvocation("SameFile", []interface{}{fi1, fi2})
	fake.sameFileMutex.Unlock()
	if fake.SameFileStub != nil {
		return fake.SameFileStub(fi1, fi2)
	}
	return fake.sameFileReturns.result1
}

func (fake *FakeOs) SameFileCallCount() int {
	fake.sameFileMutex.RLock()
	defer fake.sameFileMutex.RUnlock()
	return len(fake.sameFileArgsForCall)
}

func (fake *FakeOs) SameFileArgsForCall(i int) (os.FileInfo, os.FileInfo) {
	fake.sameFileMutex.RLock()
	defer fake.sameFileMutex.RUnlock()
	return fake.sameFileArgsForCall[i].fi1, fake.sameFileArgsForCall[i].fi2
}

func (fake *FakeOs) SameFileReturns(result1 bool) {
	fake.SameFileStub = nil
	fake.sameFileReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeOs) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findProcessMutex.RLock()
	defer fake.findProcessMutex.RUnlock()
	fake.startProcessMutex.RLock()
	defer fake.startProcessMutex.RUnlock()
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	fake.expandMutex.RLock()
	defer fake.expandMutex.RUnlock()
	fake.expandEnvMutex.RLock()
	defer fake.expandEnvMutex.RUnlock()
	fake.getenvMutex.RLock()
	defer fake.getenvMutex.RUnlock()
	fake.lookupEnvMutex.RLock()
	defer fake.lookupEnvMutex.RUnlock()
	fake.setenvMutex.RLock()
	defer fake.setenvMutex.RUnlock()
	fake.unsetenvMutex.RLock()
	defer fake.unsetenvMutex.RUnlock()
	fake.clearenvMutex.RLock()
	defer fake.clearenvMutex.RUnlock()
	fake.environMutex.RLock()
	defer fake.environMutex.RUnlock()
	fake.newSyscallErrorMutex.RLock()
	defer fake.newSyscallErrorMutex.RUnlock()
	fake.isExistMutex.RLock()
	defer fake.isExistMutex.RUnlock()
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	fake.isPermissionMutex.RLock()
	defer fake.isPermissionMutex.RUnlock()
	fake.getpidMutex.RLock()
	defer fake.getpidMutex.RUnlock()
	fake.getppidMutex.RLock()
	defer fake.getppidMutex.RUnlock()
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	fake.chdirMutex.RLock()
	defer fake.chdirMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.newFileMutex.RLock()
	defer fake.newFileMutex.RUnlock()
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	fake.truncateMutex.RLock()
	defer fake.truncateMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	fake.chtimesMutex.RLock()
	defer fake.chtimesMutex.RUnlock()
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	fake.lchownMutex.RLock()
	defer fake.lchownMutex.RUnlock()
	fake.tempDirMutex.RLock()
	defer fake.tempDirMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	fake.getwdMutex.RLock()
	defer fake.getwdMutex.RUnlock()
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	fake.isPathSeparatorMutex.RLock()
	defer fake.isPathSeparatorMutex.RUnlock()
	fake.getuidMutex.RLock()
	defer fake.getuidMutex.RUnlock()
	fake.geteuidMutex.RLock()
	defer fake.geteuidMutex.RUnlock()
	fake.getgidMutex.RLock()
	defer fake.getgidMutex.RUnlock()
	fake.getegidMutex.RLock()
	defer fake.getegidMutex.RUnlock()
	fake.getgroupsMutex.RLock()
	defer fake.getgroupsMutex.RUnlock()
	fake.exitMutex.RLock()
	defer fake.exitMutex.RUnlock()
	fake.getpagesizeMutex.RLock()
	defer fake.getpagesizeMutex.RUnlock()
	fake.sameFileMutex.RLock()
	defer fake.sameFileMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeOs) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ osshim.Os = new(FakeOs)
